## Written Report

### Images of results from running two tests cases on the BFS and Dijsktra’s algorithms:
![TEST CASE 1](https://github.com/LohitoBurrito/Airport-Project/blob/main/assets/test_case_1.png)
![TEST CASE 2](https://github.com/LohitoBurrito/Airport-Project/blob/main/assets/test_case_1.png)

### Images of results from running a tests case on the BFS and Kosaraju algorithms:
![TEST CASE 3](https://github.com/LohitoBurrito/Airport-Project/blob/main/assets/test_case_3.png)

The leading question to our project was: **which path will lead to the lowest money wastage while trying to optimize distances? How exactly should we approach this?** To solve this question, we utilized three algorithms in our project. The Breadth First Search, Dijkstra’s, and Kusaraju algorithms allowed us to configure solid ways to obtain the best corresponding airports and paths to minimize the price of the travel, given the user’s input on their current and final destinations (in latitude and longitute values). 

The **Breadth First Search (BFS)** takes in an initial starting point airport node and traverses the map of our cleaned parsed data. There are two comparisons that are performed until the condition that the queue of airport nodes are no longer not empty: the 'calcDistance' function is called twice to get the current distance to the logged departure location and the corresponding airport distance to departure location, and then twice more but with the logged destination location. Depending on the distances, the BFS function will iterate through the connections to find and set the closest start and end airport nodes. Our BFS algorithm were ran through a number of test cases, which has confirmed the algorithm to run correctly. To test the BFS, a new instance of the Airports class is created with the parameters of specific latitude and longitude double values for the starting and ending locations of airports of our choosing. There are csv files in the ‘Airport-Project/tests/data/csv/’ directory corresponding to respective test cases, which have been made to make it easier to track the airports compared to the original dataset csv. After having ran the BFS algorithm, we would ‘REQUIRE’ that the system’s variables of ‘destination’ and ‘departure’ has been set by comparing them against the string values we know to be correct. 

The **Dijkstra’s algorithm**, after having run the BFS algorithm, is used to find the most cost effective path between the given start and end airport nodes. By keeping track of the route, the algorithm iterates through the connected airports to compare the costs and obtains the least costly route between the two points. The ‘previous’ and ‘fullcost’ values of the airport nodes, from small, medium, to large, are set. The route that has been tracked from the destination node to the departure node will then be backtracked, storing this path to the ‘solution’ vector. The Dijkstra’s algorithm is tested alongside the BFS. Having passed the BFS ‘REQUIRE’ checks prior in the test cases, the Dijkstra’s will be run on the Airports object, and with another set of ‘REQUIRE’ checks, the size of the vector of Airport nodes returned by the Airports object’s ‘getSolution()’ function will be compared against the size of the route of the travel route that we know to be true (and we are able to have direct and easy control over, since we have selectively put together small scale databases for test cases, as aforementioned). We additionally can see the path taken by the Dijkstra’s algorithm by having the test cases show the path by print out each airport name of the retrieved solution vector.

**Kosaraju’s algorithm** generally returns a list of the strongly connected components of a graph. In our project, Kosaraju’s is given a starting point, and returns a list of all the airports that are strongly connected to that starting point. First, we run a DFS on all of the connections of the start point. This populates our visited graph with all of the nodes that are connected to our start point and populates our stack with the finishing order of the Airports. After that, we transpose our graph, creating a map that models the graph with reversed connections. We then create a list of every Airport that is contained in both lists. This results in a vector of every airport that is strongly connected to our starting point. After that, we use the stack to ensure the airports are returned in the correct finishing order, and return our vector.
